# -*- coding:utf-8 -*-
import random
import math
import numpy as np
import matplotlib.pyplot as plt
import json

def classify_city(goods_class):
    goods_num = len(set(goods_class))
    city_class = [[] for _ in range(goods_num)]
    for idx, g in enumerate(goods_class):
        city_class[g].append(idx)
    return city_class

def gen_case(city_num, goods_num, x_range=30, y_range=30):
    # Created as a set to prevent 2 same city positions
    city_position = set()
    while len(city_position) < city_num:
        city_position.add((random.randrange(x_range), random.randrange(y_range)))
    city_position = list(city_position)

    goods_class = list(range(goods_num))
    while len(goods_class) < city_num:
        goods_class.append(random.randrange(goods_num))
    random.shuffle(goods_class)

    city_class = classify_city(goods_class)
    return city_position, goods_class, city_class

# Your existing 5 test cases (unchanged)
def generate_cases():
    extendTSP_cases = []

    # ðŸ” Add 16 new generated test cases
    # Need to keep number of cities more than goods at all times
    # Minimum number of goods is 3 due to functionality
    for goods in (4, 8, 12, 16, 20, 24):
        for city_num in (25, 30, 35, 40, 45, 50):
            if goods <= city_num:
                extendTSP_cases.append(gen_case(city_num, goods))
    return extendTSP_cases

def record_distance(city_position):
    city_num = len(city_position)
    distance = [[0.0 for _ in range(city_num)] for _ in range(city_num)]
    for i in range(city_num):
        for j in range(i + 1, city_num):
            dis = math.sqrt(
                (city_position[i][0] - city_position[j][0]) ** 2 +
                (city_position[i][1] - city_position[j][1]) ** 2
            )
            distance[i][j] = dis
            distance[j][i] = dis
    return distance

def cal_cost(distance, path, goods_num):
    total_cost = 0
    for i in range(len(path) - 1):
        total_cost += distance[path[i]][path[i+1]]
    total_cost += distance[path[-1]][path[0]]
    return total_cost

def drawPath(city_position, best_path, title='Best Path'):
    x = [city_position[i][0] for i in best_path]
    y = [city_position[i][1] for i in best_path]
    plt.plot(x, y, marker='o')
    plt.title(title)
    for i, (x_, y_) in enumerate(city_position):
        plt.text(x_, y_, str(i))
    plt.show()

if __name__ == "__main__":
    # random.seed(42) sets the random number generator's seed to 42. 
    # This ensures that the sequence of random numbers generated by the random module 
    # will be the same every time the code is executed with the same seed.
    # When there is a need to change test cases, comment these 2 lines
    # After generated, place it back, run it again. Now its fixed
    ''' random.seed(42)
    np.random.seed(42)  '''

    extendTSP_cases = generate_cases()

    # Convert to JSON-serializable format
    serializable_cases = [
        [list(map(list, city_position)), goods_class, city_class]
        for city_position, goods_class, city_class in extendTSP_cases
    ]

    with open("tsp_cases.json", "w") as f:
        json.dump(serializable_cases, f, indent=2)

    print("Saved test cases to tsp_cases.json ")
